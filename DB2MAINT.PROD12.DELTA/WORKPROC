//DT0072X JOB ,'RDL RM102',CLASS=S,MSGCLASS=X,NOTIFY=DT0072             00000100
//**********************************************************************
//*       DSNHSQL - COMPILE AND LINKEDIT A DB2 SQL PROCEDURE
//*
//DSNHSQL PROC WSPC=500
//*
//*  Note: The DD statements for SYSCIN in step PCC and SYSIN in step C
//*        currently specify temporary data sets.  If you want to use
//*        the Debug Tool, you need to override those DD statements to
//*        specify the name of a permanent data set.  That data set
//*        must have a record format of FB and logical record length of
//*        80 bytes.  When you execute the Debug Tool, you use that
//*        data set as the input.
//*
//*        Example of overriding PCC.SYSCIN and C.SYSIN:
//*
//*        //PH063S02 EXEC DSNHSQL,MEM=SQLP
//*        //PCC.SYSCIN DD DISP=SHR,DSN=APPLDEV.DEBUG.TOOL.INPUT(SQLP)
//*        //C.SYSIN    DD DISP=SHR,DSN=APPLDEV.DEBUG.TOOL.INPUT(SQLP)
//*
//*********************************************************************
//* PC: Precompile the SQL Procedure source
//*********************************************************************
//PC      EXEC PGM=DSNHPC,
//             PARM='HOST(SQL)'
//STEPLIB  DD  DISP=SHR,DSN=SSXDT.DSNDBUG.DB2U.SDSNEXIT
//         DD  DISP=SHR,DSN=SSXDT.DSNDBUG.DB2U.SDSNLOAD
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSCIN   DD  DSN=&&DSNHSQL,DISP=(MOD,PASS),UNIT=SYSDA,
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD  DISP=SHR,DSN=SSXDT.DSNDBUG.DB2U.SRCLIB.DATA
//SYSUT1   DD  DUMMY  <-- DML to register PSM SP (V5.1 only)
//SYSUT2   DD  DUMMY  <-- DML TO REGISTER PSM SP (V6.1 ONLY)
//*********************************************************************
//* PCC: Precompile C source generated by the previous step
//*********************************************************************
//PCC     EXEC PGM=DSNHPC,
//             COND=(4,LT,PC),
//             PARM='HOST(C),MAR(1,80),SOURCE'
//STEPLIB  DD  DISP=SHR,DSN=SSXDT.DSNDBUG.DB2U.SDSNEXIT
//         DD  DISP=SHR,DSN=SSXDT.DSNDBUG.DB2U.SDSNLOAD
//DBRMLIB  DD  DISP=SHR,DSN=DT0072.DBRMLIB.DATA(TEDSSQL)
//SYSPRINT DD  SYSOUT=*
//SYSTERM  DD  SYSOUT=*
//SYSUDUMP DD  SYSOUT=*
//SYSIN    DD  DSN=&&DSNHSQL,DISP=(OLD,DELETE)
//SYSCIN   DD  DSN=&&DSNHOUT,DISP=(MOD,PASS),UNIT=SYSDA,
//             SPACE=(800,(&WSPC,&WSPC))
//SYSLIB   DD  DISP=SHR,DSN=SSXDT.DSNDBUG.DB2U.SRCLIB.DATA
//SYSUT1   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND),UNIT=SYSDA
//SYSUT2   DD  SPACE=(800,(&WSPC,&WSPC),,,ROUND),UNIT=SYSDA
//*
//*********************************************************************
//* C: Compile the output from the precompiler
//*********************************************************************
//C       EXEC PGM=EDCDC120,
//             COND=((4,LT,PC),(4,LT,PCC)),
//             PARM=('MAR(1,80) NOSEQ LO RENT')
//STEPLIB  DD  DISP=SHR,DSN=SYS1.CEE.SCEERUN
//SYSMSGS  DD  DISP=SHR,DSN=SYS1.EDC.V1R2M0.SEDCDMSG(EDCMSGE)
//SYSLIB   DD  DISP=SHR,DSN=SYS1.EDC.V1R2M0.SEDCDHDR
//         DD  DISP=SHR,DSN=SYS1.CEE.SCEEH.SYS.H
//         DD  DSN=SSXDT.DSNDBEG.DB2E.SDSNC.H,DISP=SHR
//SYSLIN   DD  DSN=&&LOADSET,DISP=(MOD,PASS),UNIT=SYSDA,
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSPRINT DD  SYSOUT=*
//SYSCPRT  DD  SYSOUT=*
//SYSTERM  DD  DUMMY
//SYSIN    DD  DSN=&&DSNHOUT,DISP=(OLD,DELETE)
//SYSUT1   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT2   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT3   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT4   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSUT5   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT6   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT7   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT8   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//SYSUT9   DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=VB,LRECL=137,BLKSIZE=882)
//SYSUT10  DD  SYSOUT=*
//SYSUT14  DD  UNIT=SYSDA,DISP=(NEW,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=3200,BLKSIZE=12800)
//*
//*********************************************************************
//* PLKED: Pre-linkedit the object module from the C compiler
//*********************************************************************
//PLKED   EXEC PGM=EDCPRLK,
//             COND=((4,LT,PC),(4,LT,PCC),(4,LT,C))
//STEPLIB  DD  DISP=SHR,DSN=SYS1.CEE.SCEERUN
//SYSMSGS  DD  DISP=SHR,DSN=SYS1.CEE.SCEEMSGP(EDCPMSGE)
//SYSLIB   DD  DUMMY
//SYSIN    DD  DSN=&&LOADSET,DISP=(OLD,DELETE)
//SYSMOD   DD  DSN=&&PLKSET,UNIT=SYSDA,DISP=(MOD,PASS),
//             SPACE=(32000,(30,30)),
//             DCB=(RECFM=FB,LRECL=80,BLKSIZE=3200)
//SYSOUT   DD  SYSOUT=*
//SYSPRINT DD  SYSOUT=*
//*
//*********************************************************************
//* LKED: Linkedit the output from the pre-linkeditor
//*********************************************************************
//LKED    EXEC PGM=IEWL,
//             COND=((4,LT,PC),(4,LT,PCC),(4,LT,C),(4,LT,PLKED)),
//             PARM='MAP'
//SYSLIB   DD  DISP=SHR,DSN=SYS1.CEE.SCEELKED
//         DD  DSN=SSXDT.DSNDBUG.DB2U.SDSNLOAD,DISP=SHR
//SYSLIN   DD  DSN=&&PLKSET,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//SYSLMOD  DD  DISP=SHR,DSN=DT0072.LOADLIB(TEDSSQL)
//SYSPRINT DD  SYSOUT=*
//SYSUT1   DD  SPACE=(32000,(30,30)),UNIT=SYSDA
//DSNHSQL PEND
//STEP01   EXEC DSNHSQL
//PC.SYSIN DD  *
CREATE PROCEDURE ROGER001
    (INOUT COMMIT_RATE INTEGER,
     INOUT RETURN_CODE INTEGER,
     INOUT SQL_CODE    INTEGER)
    DYNAMIC RESULT SET 1
    LANGUAGE SQL
    NOT DETERMINISTIC
    NO DBINFO
    MODIFIES SQL DATA
    COLLID DT0072
    WLM ENVIRONMENT WORK001
    ASUTIME NO LIMIT
    STAY RESIDENT NO
    PROGRAM TYPE MAIN
    SECURITY DB2
    CALLED ON NULL INPUT
    COMMIT ON RETURN YES
    MAIN:  BEGIN
        DECLARE  X_TKT_DOC_NB          CHAR(15);
        DECLARE  X_TKT_DOC_ISS_LDT     DATE;
        DECLARE  X_TKT_DOC_SQ_NB       SMALLINT;
        DECLARE  X_CPN_NB              SMALLINT;
        DECLARE  X_CPN_ST_TYP_CD       CHAR(1);
        DECLARE  X_CPN_SQ_NB           SMALLINT;
        DECLARE  X_CPN_PRT_LN_ID       CHAR(1);
        DECLARE  X_CPN_PRT_LN_TXT      CHAR(86);
        DECLARE  X_PRTTN_KEY_ID        DECIMAL(3);
        DECLARE  X_LST_TRNS_EVT_GTS    TIMESTAMP;
        DECLARE  ERROR_ID              INTEGER   DEFAULT 0 ;

        DECLARE    ERROR_SQLCODE       INTEGER   DEFAULT 0 ;
        DECLARE    ERROR_MSG           CHAR(25)  DEFAULT 0 ;
        DECLARE    SQLCODE             INTEGER   DEFAULT 0 ;
        DECLARE    SQLWORK             INTEGER   DEFAULT 0 ;
        DECLARE    COMMIT_FREQ         INTEGER   DEFAULT 9999999 ;
        DECLARE    ROWS_FETCHED        INTEGER   DEFAULT 0 ;
        DECLARE    BACK_LEVEL_ROWS     INTEGER   DEFAULT 0 ;
        DECLARE    ROWS_UPDATED        INTEGER   DEFAULT 0 ;

       DECLARE WORK_CURSOR CURSOR FOR
          SELECT TKT_DOC_NB,
                 TKT_DOC_ISS_LDT,
                 TKT_DOC_SQ_NB,
                 CPN_NB,
                 CPN_SQ_NB,
                 CPN_PRT_LN_ID,
                 CPN_PRT_LN_TXT,
                 PRTTN_KEY_ID,
                 LST_TRNS_EVT_GTS
          FROM WK_CPN_PRT_LN
          WHERE ERROR_ID IS NULL ;

       IF COMMIT_RATE IS NOT NULL THEN
          IF COMMIT_RATE > 0 THEN
             SET COMMIT_FREQ = COMMIT_RATE ;
          END IF;
       END IF;

       OPEN WORK_CURSOR ;
       IF SQLCODE = 0 THEN
          WHILE SQLWORK = 0 DO
             FETCH WORK_CURSOR INTO
                    X_TKT_DOC_NB,
                    X_TKT_DOC_ISS_LDT,
                    X_TKT_DOC_SQ_NB,
                    X_CPN_NB,
                    X_CPN_SQ_NB,
                    X_CPN_PRT_LN_ID,
                    X_CPN_PRT_LN_TXT,
                    X_PRTTN_KEY_ID,
                    X_LST_TRNS_EVT_GTS ;

             IF SQLCODE = 0 THEN
                SET ROWS_FETCHED = ROWS_FETCHED + 1 ;
                UPDATE XX_CPN_PRT_LN
                  SET TKT_DOC_NB = X_TKT_DOC_NB,
                  TKT_DOC_ISS_LDT = X_TKT_DOC_ISS_LDT,
                  TKT_DOC_SQ_NB = X_TKT_DOC_SQ_NB,
                  CPN_NB = X_CPN_NB,
                  CPN_SQ_NB = X_CPN_SQ_NB,
                  CPN_PRT_LN_ID = X_CPN_PRT_LN_ID,
                  CPN_PRT_LN_TXT = X_CPN_PRT_LN_TXT,
                  PRTTN_KEY_ID = X_PRTTN_KEY_ID,
                  LST_TRNS_EVT_GTS = X_LST_TRNS_EVT_GTS
                WHERE TKT_DOC_NB = X_TKT_DOC_NB
                  AND TKT_DOC_ISS_LDT = X_TKT_DOC_ISS_LDT
                  AND TKT_DOC_SQ_NB = X_TKT_DOC_SQ_NB
                  AND CPN_NB = X_CPN_NB
                  AND CPN_SQ_NB = X_CPN_SQ_NB
                  AND CPN_PRT_LN_ID = X_CPN_PRT_LN_ID
                  AND LST_TRNS_EVT_GTS <= X_LST_TRNS_EVT_GTS ;
                IF SQLCODE = 0 THEN
                   SET ROWS_UPDATED = ROWS_UPDATED + 1 ;
                   DELETE FROM WK_CPN_PRT_LN
                   WHERE TKT_DOC_NB = X_TKT_DOC_NB
                     AND TKT_DOC_ISS_LDT = X_TKT_DOC_ISS_LDT
                     AND TKT_DOC_SQ_NB = X_TKT_DOC_SQ_NB
                     AND CPN_NB = X_CPN_NB
                     AND CPN_SQ_NB = X_CPN_SQ_NB
                     AND CPN_PRT_LN_ID = X_CPN_PRT_LN_ID
                     AND LST_TRNS_EVT_GTS = X_LST_TRNS_EVT_GTS ;
                   IF SQLCODE <> 0  THEN
                      SET ERROR_MSG = 'UNABLE TO DELETE WORK ROW' ;
                      SET ERROR_SQLCODE = SQLCODE ;
                      INSERT INTO TEDS_ERROR_LOG
                         (ERROR_SQLCODE, ERROR_MSG)
                         VALUES
                         (ERROR_SQLCODE, ERROR_MSG) ;
                   END IF ;
                ELSEIF SQLCODE = 100 THEN
                   DELETE FROM WK_CPN_PRT_LN
                   WHERE TKT_DOC_NB = X_TKT_DOC_NB
                     AND TKT_DOC_ISS_LDT = X_TKT_DOC_ISS_LDT
                     AND TKT_DOC_SQ_NB = X_TKT_DOC_SQ_NB
                     AND CPN_NB = X_CPN_NB
                     AND CPN_SQ_NB = X_CPN_SQ_NB
                     AND CPN_PRT_LN_ID = X_CPN_PRT_LN_ID
                     AND LST_TRNS_EVT_GTS = X_LST_TRNS_EVT_GTS ;
                     IF SQLCODE = 0 THEN
                        SET BACK_LEVEL_ROWS = BACK_LEVEL_ROWS + 1   ;
                     ELSE
                        SET ERROR_MSG = 'UNABLE TO DELETE WORK ROW' ;
                        SET ERROR_SQLCODE = SQLCODE ;
                        INSERT INTO TEDS_ERROR_LOG
                           (ERROR_SQLCODE, ERROR_MSG)
                           VALUES
                           (ERROR_SQLCODE, ERROR_MSG) ;
                        SET SQLWORK = SQLCODE ;
                        SET SQL_CODE = SQLCODE ;
                        SET RETURN_CODE = 16 ;
                     END IF ;
                ELSE
                   SET ERROR_MSG = 'UPDATE FAILURE ENCOUNTERED' ;
                   SET ERROR_SQLCODE = SQLCODE ;
                   INSERT INTO TEDS_ERROR_LOG
                      (ERROR_SQLCODE, ERROR_MSG)
                      VALUES
                      (ERROR_SQLCODE, ERROR_MSG) ;
                   IF SQLCODE <> 0 THEN
                      SET SQLWORK = SQLCODE ;
                      SET SQL_CODE = SQLCODE ;
                      SET RETURN_CODE = 16 ;
                   END IF ;
                END IF ;

             ELSEIF SQLCODE = 100 THEN
                   SET SQLWORK = SQLCODE ;
                ELSE
                   SET SQLWORK = SQLCODE ;
                   SET ERROR_MSG = 'CURSOR FETCH ERROR ' ;
                   SET ERROR_SQLCODE = SQLCODE ;
                   INSERT INTO TEDS_ERROR_LOG
                      (ERROR_SQLCODE, ERROR_MSG)
                      VALUES
                      (ERROR_SQLCODE, ERROR_MSG) ;
                   IF SQLCODE <> 0 THEN
                      SET SQLWORK = SQLCODE ;
                      SET SQL_CODE = SQLCODE ;
                      SET RETURN_CODE = 16 ;
                   END IF ;
             END IF ;
          END WHILE ;
       CLOSE WORK_CURSOR ;

       ELSEIF SQLCODE = 100 THEN
          SET SQLWORK = SQLCODE ;
          SET ERROR_MSG = 'CURSOR FETCH ERROR ' ;
          SET ERROR_SQLCODE = SQLCODE ;
          INSERT INTO TEDS_ERROR_LOG
             (ERROR_SQLCODE, ERROR_MSG)
             VALUES
             (ERROR_SQLCODE, ERROR_MSG) ;
          IF SQLCODE <> 0 THEN
             SET SQLWORK = SQLCODE ;
             SET SQL_CODE = SQLCODE ;
             SET RETURN_CODE = 16 ;
          END IF ;
       END IF ;


    END MAIN
/*
//
